### mpvue

上一个项目采用了 `mpvue` 做跨端框架，对跨端这一层感触颇深，甚至导致我 ** 不想写前端了 🙄  

#### 跨端
由来: 前端的 **端** 实在太多了，说白了也就是宿主容器太多了: 各大浏览器(即 Web)/App/各大小程序/快应用/树莓派/其他。因为我们和后端不一样，后端是 **面向机器（服务器）编程**，他们可以选择机器，我们
然后带来了一个致命问题
- 多端开发效率，代码如何复用？

于是乎，前端er 都想着怎么用 js 才能一统天下
- App 开始有了 React-Native/Weex
- Web/小程序 开始有了 Mpvue/Taro
- 以及其他一大堆号称跨所有端的框架

我想说的就是，别瞎搞了，只要你有会变的宿主，你就甭想搞一个通用的东西去适配所有宿主。适用性最强的就是 做一层 bridge，让 bridge 去适配所有端，bridge 提供一套接口出来让 上层去调用。（我用 mpvue 的时候，就是这样做的🙄）  

然而这些没啥卵用，因为每个宿主可能都有些变态的东西，比如生命周期，底层能力限制等问题，你看微信小程序，所有打开过的页面（在小程序实例没被销毁前，都缓存了页面视图层）。说白了，每个端特殊的兼容性的处理，不是一套通用能力就能处理的

当然，还有种方式，webview 架构，就是多端统一内嵌 webview，webview 上层则是各端的通用能力。当然，这种性能上肯定是不好的，尤其是处理频繁调用的事件（简单的那些应用都不在我们讨论的范围内）。**当然你牛逼的话，也可以直接拍死 pd/ued**

#### 扯远了，最近架构上有一点小小心得，当然，我们先说问题:
- 我嫌弃 mpvue 性能差，哪怕你的 setData 做了 50ms 的节流，只要你 vue 组件上挂了 十几二十几长度 的数组，我保证你 双向绑定的输入框 输入内容的时候，内容会回跳，嘿嘿嘿。（你千万别和我说，我页面就一个输入框，就算挂了长数组，输入的时候也不会出现啊）。没 diff 出该改变的东西，每次 setData 都是把所有组件状态一股脑的塞进去，不卡才怪了。据说 Taro 做了 diff，但是我没用过 🙄
- 动态组件，没办法，这点由于宿主环境，即微信小程序是预编译好的，所以像 Hoc 这种就省省吧，老老实实的组件写好，根据组件上的状态去渲染不同组件吧。指令，DOM 这些也就不说了
- 生命周期，除非 v-if 形式的 挂载/卸载 组件，不然组件的 beforeDestory/destroyed 就算页面离开了，也甭想触发了。没办法，你的宿主决定了很多东西能不能奏效
- ...... 填坑无数

#### 下面我的架构方式，也很简单:
- 高性能的场景下，我们把转换层当作 **数据中转中心**，很简单，比如 我们把 mpvue 这一层做数据初始化/收集/分发事件，他不会处理 view 层的东西（除了注入初始数据），其他的都交给原生组件去处理页面的状态，性能杠杠的（说白了，就多写点原生组件吧，当然这样就带来了 多端难以复用原生组件代码 的成本）
- 简单的场景下，我们评估能效 去考虑是否直接用 mpvue 这一层去处理 view 层

### 串行

1. 串行就像是一个任务队列, 任务按顺序进入, 先进先出
2. 单线程即可


### 并行

1. 多个任务同时执行, 先完成的先走
2. 多线程

### 最近在思考如何异步 IO 的优化

#### 如何让多个请求, 或者说多个异步任务, **同时**执行, 进而缩短时间

> JavaScript 中
```javascript
const arr = Array.from({ length: 10 }).map((e, i) => i)
const fn = (i) => new Promise((resolve, reject) => {
  setTimeout(() => resolve(i), 2000)
})

// 1
Promise.all(arr.map(fn))

// 2
// ES2018, 说是串行执行
(async () => {
  for await (let i of arr) {
    fn(`2: ${i}`)
  }
})()

// 3
(async () => {
  for (let i of arr) {
    await fn(`3: ${i}`)
  }
})()

```

曾经我一直用第 3 种方式执行，现在想想，特么真的是醉了，这样搞的话, 每次都要等上一个异步操作完成, 简直慢的一匹啊，可谓是真正的 `串行` ... WTF🙃 ... 但是吧, 这种方式也保障了执行时, 会抛出异常, 不会执行下去(呵呵, Promise.all 不也一样)。

后来我开始用第 1 种, 这种应该是 `异步 IO` 在底层的线程池里是并行执行, 最终会等所有任务都完成后, 再返回结果。然后速度快了好几倍...

现在 `ES2018` 出了第 2 种, 还没有试过是不是和第 3 种一样的`串行`......😅

#### 总结

- 第 1 种适合无关联性的查询或其他操作
- 第 2 种暂不谈
- 第 3 种适合严格按顺序执行任务的队列(任务关联性), 比如稳定的按顺序插入数据 等(不过你直接用事务写, 就没这啥事了, hhh)
